{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["hasCommandModifier","KeyBindingUtil","tokenizer","natural","WordPunctTokenizer","lexicon","Lexicon","ruleSet","RuleSet","tagger","BrillPOSTagger","styleMap","backgroundColor","MyEditor","props","useState","EditorState","createEmpty","editorState","setEditorState","editor","useRef","focusEditor","current","focus","useEffect","readOnly","setReadOnly","myEditorState","getCurrentContent","getBlockMap","map","v","selection","SelectionState","key","tokens","tokenize","text","tags","tag","taggedWords","index","forEach","w","i","indexOf","merge","anchorOffset","focusOffset","length","posTag","code","word","mapPOSCode","newState","Modifier","applyInlineStyle","push","filter","setFilter","removeStyles","selectionParam","stateParam","except","getSelection","Object","keys","k","removeInlineStyle","applyPosStyle","pos","getAnchorOffset","getFocusOffset","onClick","className","Sticky","enabled","onMouseDown","e","preventDefault","contentState","rawContent","convertToRaw","stringContent","JSON","stringify","file","Blob","type","window","navigator","msSaveOrOpenBlob","a","document","createElement","url","URL","createObjectURL","href","download","body","appendChild","click","setTimeout","removeChild","revokeObjectURL","for","onChange","event","target","files","reader","FileReader","onload","rawState","parse","result","loadedState","convertFromRaw","createWithContent","readAsText","id","style","alignSelf","ref","customStyleFn","s","b","toJS","opacity","handleKeyCommand","command","keyBindingFn","keyCode","getDefaultKeyBinding","preserveSelectionOnBlur","placeholder","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.946b5950.chunk.js","sourcesContent":["import React, {useEffect, useRef, useState} from 'react';\nimport {Editor, EditorState, \n  SelectionState, Modifier, \n  getDefaultKeyBinding, KeyBindingUtil,\n  convertToRaw, convertFromRaw} from 'draft-js';\nimport 'draft-js/dist/Draft.css';\nimport './App.css';\nimport natural from 'natural';\nimport Sticky from 'react-stickynode';\nimport {RiFilterFill} from 'react-icons/ri';\nimport {FaRemoveFormat} from 'react-icons/fa';\nimport {AiFillGithub} from 'react-icons/ai';\n// talisman package also has potential, different tokenizers, like syllables...\n// would be nice to find a chunking algorithm to get nun phrases, etc...\n// also would be nice to find phonetics algorithm that converts to IPA (alphabet)\n// to look at rhymes and stressed/unstressed syllables\n\n/*\n  next steps:\n  - perf/readonly style\n  - adjustable tags? (like what if prepositions or phrases)\n  - look into nlp chunker ?\n  - hosted/canonical examples?\n  - make code not suck :)\n*/\n\nconst {hasCommandModifier} = KeyBindingUtil;\n\nconst tokenizer = new natural.WordPunctTokenizer()\n// const tokenizer = new natural.TreebankWordTokenizer();\n// tokenizer = new natural.SentenceTokenizer();\n\nconst lexicon = new natural.Lexicon('EN', 'N', 'NNP');\nconst ruleSet = new natural.RuleSet('EN');\nconst tagger = new natural.BrillPOSTagger(lexicon, ruleSet);\n\nlet styleMap = {\n  'NOUN': {\n    backgroundColor: '#EFE347',\n  },\n  'VERB': {\n    backgroundColor: '#EFA675',\n  },\n  'ADJECTIVE': {\n    backgroundColor: '#D291BC',\n  },\n  'ADVERB': {\n    backgroundColor: '#FFDFD3',\n  },\n  'PUNCTUATION': {\n    backgroundColor: 'white',\n  },\n};\n\nfunction mapPOSCode(code, word) {\n  if (word === 'â€”') { // maybe a regex or something? idk..\n    return 'PUNCTUATION';\n  }\n\n  // idk: EX, FW, LS, POS, SYM\n  switch(code) {\n    /*\n    case 'CC':\n    case 'IN':\n    case 'TO':\n      return 'CONJUNCTION';\n    */\n    case '.':\n    case ',':\n    case '(':\n    case ')':\n      return 'PUNCTUATION'\n    /*\n    case 'RP':\n    case 'DT':\n    case 'WDT':\n    case 'PDT':\n    case 'UH':\n      return 'PARTICLE';\n    */\n    case 'JJ':\n    case 'JJR':\n    case 'JJS':\n      return 'ADJECTIVE';\n    // case 'MD':\n    case 'VB':\n    case 'VBD':\n    case 'VBG':\n    case 'VBN':\n    case 'VBP':\n    case 'VBZ':\n    case 'VBT':\n      return 'VERB';\n    case 'RB':\n    case 'RBR':\n    case 'RBS':\n    case 'WRB':\n      return 'ADVERB';\n    case 'NN':\n    case 'NNS':\n    case 'NNP':\n    case 'NNPS':\n    case 'NN':\n    case 'PRP':\n    // case 'PRP$':\n    case 'WP':\n    // case 'WP$':\n      return 'NOUN';\n  }\n}\n\nfunction MyEditor(props) {\n  const [editorState, setEditorState] = useState(\n    EditorState.createEmpty()\n  );\n \n  const editor = useRef(null);\n \n  function focusEditor() {\n    editor.current.focus();\n  }\n \n  useEffect(() => {\n    focusEditor()\n  }, []);\n\n  // do I need to use readonly? I could have callback..\n  const [readOnly, setReadOnly] = useState(false);\n  useEffect(() => {\n    if (readOnly) {\n      let myEditorState = editorState;\n      const editorContent = myEditorState.getCurrentContent();\n      editorContent.getBlockMap().map((v) => {\n        let selection = SelectionState.createEmpty(v.key);\n        \n        const tokens = tokenizer.tokenize(v.text);\n        const tags = tagger.tag(tokens).taggedWords;\n\n        let index = 0;\n        tokens.forEach((w, i) => {\n\n          index = v.text.indexOf(w, index);\n          selection = selection.merge({\n            anchorOffset: index,\n            focusOffset: index + w.length,\n          });\n\n          const posTag = mapPOSCode(tags[i].tag, w);\n          if (posTag) {\n            const newState = Modifier.applyInlineStyle(\n              myEditorState.getCurrentContent(),\n              selection,\n              posTag\n            );\n\n            myEditorState = EditorState.push(myEditorState, newState, \"change-inline-style\");\n          } else {\n            // console.log(`missed tag: ${w}, ${tags[i].tag}`);\n          }\n\n          index += w.length;\n        });\n      });\n\n      setEditorState(myEditorState);\n      setReadOnly(false);\n    }\n  }, [readOnly]);\n\n  const [filter, setFilter] = useState(null);\n\n  function removeStyles(selectionParam, stateParam, except) {\n    const selection = selectionParam || editorState.getSelection();\n    let newState = stateParam || editorState.getCurrentContent();\n\n    Object.keys(styleMap).forEach((k) => {\n      if (k !== except) {\n        newState = Modifier.removeInlineStyle(\n          newState,\n          selection,\n          k\n        );\n      }\n    });\n\n    setEditorState(EditorState.push(editorState, newState, \"change-inline-style\"));\n  }\n\n  function applyPosStyle(pos) {\n    const selection = editorState.getSelection();\n    if (selection.getAnchorOffset() !== selection.getFocusOffset()) {\n      let newState = Modifier.applyInlineStyle(\n        editorState.getCurrentContent(),\n        selection,\n        pos\n      );\n\n      removeStyles(selection, newState, pos);\n    }\n  }\n\n  function myKeyBindingFn(e) {\n    if (e.keyCode === 78 /* `N` key */ && hasCommandModifier(e)) {\n      return 'noun';\n    } else if (e.keyCode === 71 /* `G` key */ && hasCommandModifier(e)) {\n      return 'verb';\n    } else if (e.keyCode === 74 /* `J` key */ && hasCommandModifier(e)) {\n      return 'adjective';\n    } else if (e.keyCode === 84 /* `T` key */ && hasCommandModifier(e)) {\n      return 'adverb';\n    } else if (e.keyCode === 72 /* `H` key */ && hasCommandModifier(e)) {\n      return 'punctuation';\n    } else if (e.keyCode === 66 /* `B` key */ && hasCommandModifier(e)) {\n      return 'clearTag';\n    }\n    return getDefaultKeyBinding(e);\n  }\n\n  function handleKeyCommand(command) {\n    if (command === 'noun') {\n      applyPosStyle('NOUN');\n      return 'handled';\n    } else if (command === 'verb') {\n      applyPosStyle('VERB');\n      return 'handled';\n    } else if (command === 'adjective') {\n      applyPosStyle('ADJECTIVE');\n      return 'handled';\n    } else if (command === 'adverb') {\n      applyPosStyle('ADVERB');\n      return 'handled';\n    } else if (command === 'punctuation') {\n      applyPosStyle('PUNCTUATION');\n      return 'handled';\n    } else if (command === 'clearTag') {\n      removeStyles();\n      return 'handled';\n    }\n    return 'not-handled';\n  }\n\n  function save() {\n    const contentState = editorState.getCurrentContent();\n    const rawContent = convertToRaw(contentState);\n    const stringContent = JSON.stringify(rawContent);\n\n    const file = new Blob([stringContent], {type: 'json'});\n    if (window.navigator.msSaveOrOpenBlob) // IE10+\n        window.navigator.msSaveOrOpenBlob(file, 'draft.json');\n    else { // Others\n        const a = document.createElement(\"a\");\n        const url = URL.createObjectURL(file);\n        a.href = url;\n        a.download = 'draft.json';\n        document.body.appendChild(a);\n        a.click();\n        setTimeout(function() {\n            document.body.removeChild(a);\n            window.URL.revokeObjectURL(url);  \n        }, 0); \n    }\n  }\n\n  function load(event) {\n    const file = event.target.files[0];\n    const reader = new FileReader();\n    reader.onload = function(e) {\n      const rawState = JSON.parse(e.target.result);\n      const loadedState = convertFromRaw(rawState);\n      setEditorState(EditorState.createWithContent(loadedState));\n    };\n\n    reader.readAsText(file);\n  }\n  \n  return (\n    <div onClick={focusEditor} className=\"editor-container\">\n      <Sticky enabled={true}>\n        <div className=\"button-container\" onMouseDown={(e) => e.preventDefault()}>\n          <div className=\"left-buttons-container\">\n            <button\n              onClick={() => setReadOnly(true)}\n            >\n              Auto-tag\n            </button>\n            <div className=\"save-load-btns\">\n              <button onClick={save}>Save</button>\n              <label for=\"file-select\">Load</label>\n              <input type=\"file\" onChange={load} id=\"file-select\" />\n            </div>\n          </div>\n\n          <div className=\"pos-toolbar\">\n            <div style={{alignSelf: 'center'}}>\n              <button \n                className=\"clear-style-btn\"\n                onClick={() => removeStyles()}\n              >\n                <FaRemoveFormat />\n              </button>\n            </div>\n            {Object.keys(styleMap).map((k) => \n              <div className=\"pos-buttons\">\n                <div className=\"pos-row\">\n                  <div \n                    className=\"pos-color\" \n                    style={{\n                      backgroundColor: styleMap[k].backgroundColor,\n                    }}\n                  />\n                  <button\n                    className={`filter-btn ${filter === k ? 'filtered' : ''}`}\n                    onClick={(e) => {\n                      e.preventDefault();\n                      setFilter(filter === k ? null : k);\n                    }}\n                  >\n                    <RiFilterFill />\n                  </button>\n                </div>\n                <button \n                  className=\"pos-button\"\n                  onClick={(e) => {\n                    e.preventDefault();\n                    applyPosStyle(k);\n                  }}\n                >\n                  {k}\n                </button>\n              </div>\n            )}\n          </div>\n\n        </div>\n      </Sticky>\n      <Editor\n        key={filter}\n        ref={editor}\n        editorState={editorState}\n        /* customStyleMap={styleMap} */\n        customStyleFn={(s, b) => {\n          const tag = s.toJS()[0];\n          if (filter) {\n            if (filter === tag) {\n              return {\n                backgroundColor: 'transparent',\n              };\n            } else {\n              return {\n                backgroundColor: 'transparent',\n                opacity: 0.1,\n              };\n            }\n          }\n\n          if (tag && styleMap[tag]) {\n            return styleMap[tag];\n          }\n        }}\n        onChange={editorState => setEditorState(editorState)}\n        handleKeyCommand={handleKeyCommand}\n        keyBindingFn={myKeyBindingFn}\n        preserveSelectionOnBlur={true}\n        placeholder={`Enter text here`}\n        readOnly={readOnly}\n        {...props}\n      />\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MyEditor />\n      <div className=\"github-link\">\n        <a href=\"https://github.com/ryapapap/prose-tagger\"> Source <AiFillGithub /></a>        \n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}